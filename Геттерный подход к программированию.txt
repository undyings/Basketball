
Геттерный подход к программированию

Состояние программы можно разделить на исходное и производное от исходного. Исходное состояние
не может быть получено самой программой, оно задается внешним образом (пользователем, с диска и т.п.)
Производное состояние может быть рассчитано программой на основе исходного состояния.

Например, программа работает со списком машин и выбранной машиной. И в программе есть
комбобокс для выбора машины из списка. Список машин и выбранная машина это исходное состояние.
Комбобокс для выбора машин это производное состояние, т.к. состояние этого комбобокса может
быть корректно сформировано программой на основе списка машин и выбранной машины.


1) Существует два подхода к программированию: 1) событийный (общепринятый) 2) геттерный.

1.1) При событийном подходе при изменении состояния обработчик отвечает как за изменение исходного,
так и за изменение производного состояния. Например, при удалении машины из списка обработчик 
этого события должен не только удалить машину из исходного списка, но и удалить элемент
комбобокса связанный с этой машиной. Соответственно в событийном подходе при любой модификации
состояния нам нужно держать в голове полную модель системы, включающую в себя как исходное,
так и производное состояние.

1.2) При геттерном подходе явным образом модифицируется только исходное состояние, производное
состояние рассчитывается автоматически на основе исходного состояния. Соответственно при
модификации состояния системы в голове достаточно держать только модель исходных состояний,
которая много проще, чем модель полного состояния системы.


2) Для формирования производного состояния используются RawCache<T>.

2.1) Автоматический кэш (RawCache<T>) имеет произвольное количество входов и метод формирующий 
возвращаемое значение (типа T) на основе значений входов. При вызове свойства cache.Result 
проверяется состояние входов, если хотя бы один из входов изменился, то вызывается метод
формирующий возвращаемое значение и значение кэша пересчитывается, иначе возвращается
кэшированное значение.

Например, у нас есть контрол определенного размера, для нее нам внутри программы нужно
хранить картинку такого же размера. При событийном подходе при изменении размеров контрола
мы должны явным образом пересоздать картинку. При геттерном подходе картинка
оформляется в виде автоматического кэша зависящего от размеров контрола. 

  RawCache<Image> imageCache = new Cache<Image, Size>(
    delegate(Size size) //Обработчик
    {
      return new Bitmap(size.Width, size.Height);
    },
    delegate { return control.Size; } //Вход
  );

Такой код позволяет нам менять размеры контрола не помня и не задумываясь о том, что от размеров
контрола зависит картинка, т.к. автоматический кэш гарантирует нам, что полученная
из него картинка всегда будет в актуальном состоянии.

!!! Для веб-проектов следующий пункт не актуален. NitroBolt.Wui изначально строится на геттерном подходе.
2.2) При необходимости работать с фрамеворком использующим событийный подход (например, WinForms) автоматические кэши дополняются ленивыми работниками, которые используются для изменения состояния контролов фрамеворка.

Ленивый работник (LazyMaker) имеет произвольное количество входов и обработчик. 
При вызове метода lazyMaker.Make() проверяется состояние входов и если хотя бы один
из входов изменился, то вызывается обработчик.

Например, если нужен комбобокс для выбора машины из списка, то заполнение комбобокса оформляется
как LazyMaker с двумя входами: 1) список машин 2) выбранная машина. В событии обрабатывающем удаление
машины мы изменяем только исходный список машин. После чего вызываем lazyMaker.Make(). Соответственно
из скольки бы мест мы ни модифицировали исходное состояние, для формирования производного состояния
вызывается всегда один и тот же код.

  LazyMaker comboFiller = new LazyMaker<string[], string>(
    delegate(string[] cars, string selectedCar) //Обработчик
    {
      combo.Items.Clear();
      foreach (string car in cars)
      {
        combo.Items.Add(car);
      }
      combo.SelectedItem = selectedCar;
    },
    delegate { return allCars; },    //1-ый вход
    delegate { return selectedCar; } //2-ой вход 
  );


3) При использовании геттерного подхода код разбивается на следующие части:

- Исходное состояние
- Набор автоматических кэшей формирующих производное состояние
  на основе исходного состояния


!!! Для веб-проектов следующий пункт не актуален. NitroBolt.Wui изначально строится на геттерном подходе.
При необходимости работать с фрамеворком использующим событийный подход (например, WinForms) дополнительно нужны:
- Ленивые работники, устанавливающие состояние контролов событийного фрамеворка на основе исходного состояния
- Обработчики событий, в которых модифицируется исходное состояние, после чего вызывается
  функция VisibilityRefresh(), в которую помещяются вызовы всех ленивых работников:
  
    void VisibilityRefresh()
    {
      comboFiller.Make();
    }
  
Если работа происходит с контролом/формой, то вызов VisibilityRefresh желательно поместить также
в перегрузку OnPaint:

    protected override void OnPaint(PaintEventArgs e)
    {
      VisibilityRefresh();

      base.OnPaint(e);
    }

В этом случае для приведения состояния программы в корректное состояние в обработчике события
после изменения исходного состояния достаточно вызвать VisibilityRefresh()

!!! VisibilityRefresh желательно вызывать в конце конструктора, т.к. OnPaint контрола часто не вызывается
фрамеворком по различным причинам